"""
this module handles the core initialization of the coglex framework, including:
- flask application setup and configuration
- database connection and initialization
- authentication decorators setup
- service module registration
"""


# python's built-in function wrappers
from functools import wraps

# pip install flask
# micro server routing, services, templating, and http serving toolkit
from flask import Flask, request, session, abort

# pip install pymongo
# initialize mongodb client
from pymongo import MongoClient

# pip install stripe
# online payment processing provider
import stripe

# importing base config parameters, and generic utilities
import config

# importing generic utilities
from utils import jwtdec


# server application / coglex container
application = Flask(config.APP_IMPORT, template_folder=config.APP_TEMPLATES, static_folder=config.APP_STATIC)

# application's extra config
application.config.from_mapping({
    "SECRET_KEY": config.SERVER_SECRET,
    "PERMANENT_SESSION_LIFETIME": config.SERVER_SESSION_LIFETIME,
    "UPLOAD_FOLDER": config.APP_UPLOAD,
    "MAX_CONTENT_LENGTH": config.MAX_CONTENT_LENGTH,
    "SEND_FILE_MAX_AGE_DEFAULT": config.SEND_FILE_MAX_AGE,
})

# connect to mongodb with credentials
storage = MongoClient(config.MONGODB_URI).get_database(config.MONGODB_DATABASE)

# setting up stripe payment api key
stripe.api_key = config.STRIPE_SECRET_KEY

# server key requirement decorator for routes
def protected(function):
    """
    decorator that protects routes by requiring a valid server key in request headers
    
    args:
        function: the route handler function to protect
        
    returns:
        decorator: a wrapped function that checks for valid server key before executing the handler
    """
    @wraps(function)
    def decorator(*args, **kwargs):
        # check if key exists in request headers and is valid
        if request.headers.get("X-API-Key") == config.SERVER_SECRET:
            return function(*args, **kwargs)

        return abort(401)

    return decorator


# user auth requirement decorator for routes
def authenticated(function):
    """
    decorator that protects routes by requiring a valid jwt
    the jwt is expected in the "authorization" header as a bearer token

    args:
        function: the route handler function to protect
        
    returns:
        decorator: a wrapped function that validates user authentication
    """
    @wraps(function)
    def decorator(*args, **kwargs):
        # get token from request headers
        token = request.headers.get("Authorization", "").replace("Bearer ", "")

        if not token:
            return abort(401)

        # decoding the token
        decoding = jwtdec(token)

        # checking if succesful token decoding
        if not decoding:
            return abort(401)

        # let's check if collection and authentication exits in session, then the token is generated by us indeed
        # this doesnâ€™t seem to have much of a great impact, since we are using the collection value to authenticate the user, but it seems like a logical reason to check if the user did pass by the normal process of signin-in to have a valid session
        if decoding.get("collection") not in session or not decoding.get("_key") or not decoding.get("_password") or not session.get(decoding.get("collection")):

            return abort(401)

        # importing generic utilities
        from coglex.services.auth.utils import signin

        # authenticate user
        _, authentication = signin(decoding.get("collection"), decoding.get("_key"), decoding.get("_password")) or (None, None)

        # if user doesn't exist or is inactive to the given query, return 401
        if not authentication:
            return abort(401)

        # update session with latest user data
        session.update({
            decoding.get("collection"): authentication
        })

        # if we get here, token is valid and user verified
        return function(*args, **kwargs)

    return decorator


# importing service modules
from coglex.services.auth.routes import auth as auth_service
from coglex.services.storage.routes import storage as storage_service
from coglex.services.archive.routes import archive as archive_service
from coglex.services.execution.routes import execution as execution_service
from coglex.services.payment.routes import payment as payment_service


# register service blueprints with application
application.register_blueprint(auth_service)
application.register_blueprint(storage_service)
application.register_blueprint(archive_service)
application.register_blueprint(execution_service)
application.register_blueprint(payment_service)
