"""
this module handles the core initialization of the coglex framework, including:
- flask application setup and configuration
- database connection and initialization
- authentication decorators setup
- service module registration
"""


# standard library imports
import os

# python's built-in function wrappers
from functools import wraps

# pip install flask
# micro server routing, services, templating, and http serving toolkit
from flask import Flask, request, session, jsonify, abort

# pip install pymongo
# initialize mongodb client
from pymongo import MongoClient

# pip install stripe
# online payment processing provider
import stripe

# importing base config parameters, and generic utilities
import config

# importing generic utilities
from utils import jwtdec


# server application / coglex container
application = Flask(config.APP_IMPORT, template_folder=config.APP_TEMPLATES, static_folder=config.APP_STATIC)

# application's extra config
application.config.from_mapping({
    "SECRET_KEY": config.SERVER_SECRET,
    "PERMANENT_SESSION_LIFETIME": config.SERVER_SESSION_LIFETIME,
    "UPLOAD_FOLDER": config.APP_UPLOAD,
    "MAX_CONTENT_LENGTH": config.MAX_CONTENT_LENGTH,
    "SEND_FILE_MAX_AGE_DEFAULT": config.SEND_FILE_MAX_AGE,
})

# connect to mongodb with credentials
storage = MongoClient(config.MONGODB_URI).get_database(config.MONGODB_DATABASE)

# setting up stripe payment api key
stripe.api_key = config.STRIPE_SECRET_KEY

# server key requirement decorator for routes
def protected(function):
    """
    decorator that protects routes by requiring a valid server key in request headers
    
    args:
        function: the route handler function to protect
        
    returns:
        decorator: a wrapped function that checks for valid server key before executing the handler
    """
    @wraps(function)
    def decorator(*args, **kwargs):
        # check if key exists in request headers and is valid
        if request.headers.get("X-API-Key") == config.SERVER_SECRET:
            return function(*args, **kwargs)

        return abort(401)

    return decorator


# user auth requirement decorator for routes
def authenticated(function):
    # PROBLEM: session is not updated within this authentication decorator. SOLVED: it gets updated everytime, must be optimized later
    # PROBLEM: token is presistent, everytime it is sent, it is valid if only it contains collection and original login. SOLVED: added expiration to token
    """
    decorator that protects routes by requiring a valid jwt
    the jwt is expected in the "authorization" header as a bearer token

    args:
        function: the route handler function to protect
        
    returns:
        decorator: a wrapped function that validates user authentication
    """
    @wraps(function)
    def decorator(*args, **kwargs):
        # get token from request headers
        token = request.headers.get("Authorization", "").replace("Bearer ", "")

        if not token:
            return abort(401)

        # decoding the token
        decoding = jwtdec(token)

        # checking if succesful token decoding
        if not decoding:
            return abort(401)

        # let's check if collection and authentification is exactly what we have stored in session or not
        # NOTE: this is not going to work since session is updated everytime on this code block, but the token is still the same that the user uses, so we need to check if the token is valid
        # if decoding.get("collection") not in session or session.get(decoding.get("collection")) != decoding.get("query"):
        #     return abort(401)

        # let's check if collection and authentication exits in session, then the token is generated by us indeed
        # NOTE: this doesnâ€™t seem to have much of a great impact, since we are using the collection value to authenticate the user, but it seems like a logical reason to check if the user did pass by the normal process of signin-in to have a valid session
        if decoding.get("collection") not in session or not session.get(decoding.get("collection")):
            return abort(401)

        # importing generic utilities
        from coglex.services.auth.utils import signin

        # authenticate user
        _, authentication = signin(decoding.get("collection"), decoding.get("query")) or (None, None)

        # if user doesn't exist or is inactive to the given query, return 401
        if not authentication:
            return abort(401)

        # update session with latest user data
        session.update({
            decoding.get("collection"): authentication
        })

        # if we get here, token is valid and user verified
        return function(*args, **kwargs)

    return decorator


# importing service modules
from coglex.services.auth.routes import auth as auth_service
from coglex.services.storage.routes import storage as storage_service
from coglex.services.archive.routes import archive as archive_service
from coglex.services.execution.routes import execution as execution_service
from coglex.services.payment.routes import payment as payment_service


# register blueprints with application
application.register_blueprint(auth_service)
application.register_blueprint(storage_service)
application.register_blueprint(archive_service)
application.register_blueprint(execution_service)
application.register_blueprint(payment_service)
